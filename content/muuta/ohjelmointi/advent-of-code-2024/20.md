---
title: "Advent of Code 2024: 20. p√§iv√§"
linkTitle: "20. p√§iv√§"
lastmod: 2024-12-20T16:31:00+0200
summary: "Labyrinttirallia seinien l√§pi juoksemalla"
---
### Ensimm√§inen osa

T√§m√§n vuoden Advent of Code tuntuu olevan t√§ynn√§ reitinhakualgoritmeja vaativia teht√§vi√§, sill√§ my√∂s t√§n√§√§n ollaan labyrinttien keskell√§.

Sy√∂tteen√§ on j√§lleen tutun n√§k√∂inen labyrintti, jossa `#` kuvaa seini√§ ja `S` sek√§ `E` ovat aloitus- ja lopetuspisteet. Toisin kuin aikaisemmat labyrintit, t√§ss√§ on olemassa vain yksi reitti eli risteyks√§ ei ole. Alla on esimerkkilabyrintti:

{{< highlight text >}}
###############
#...#...#.....#
#.#.#.#.#.###.#
#S#...#.#.#...#
#######.#.#.###
#######.#.#...#
#######.#.###.#
###..E#...#...#
###.#######.###
#...###...#...#
#.#####.#.###.#
#.#...#.#.#...#
#.#.#.#.#.#.###
#...#...#...###
###############
{{< /highlight >}}

Mukana on kuitenkin pieni koukku: saamme huijata. Labyrintin aikana k√§ytett√§viss√§ on kaksi askelta, joiden aikana voimme kulkea seinien l√§pi. T√§m√§ tarkoittaa sit√§, ett√§ voimme kulkea yhden sein√§n l√§pi ja oikaista. Ongelmana on tietenkin se, ett√§ miss√§ kohtaa t√§m√§ supervoima kannattaa k√§ytt√§√§.

Teht√§v√§n√§ selvitt√§√§ kaikki sellaiset huijauksen paikat, jotka s√§√§st√§v√§t v√§hint√§√§n 100 askelta.

En ollut erityisen tyytyv√§inen siihen, millainen k√∂t√∂stys aikaisemmin tekem√§st√§ni [A*-algoritmista](https://en.wikipedia.org/wiki/A*_search_algorithm) syntyi. Halusin tehd√§ sen paremmin.

En yleens√§ k√§yt√§ AoC-haasteissa ulkopuolisia kirjastoja, mutta t√§m√§n kohdalla annoin itselleni luvan hy√∂dynt√§√§ [x1m3/priorityQueue](https://github.com/x1m3/priorityQueue) -pakettia, joka tarjoaa n√§pp√§r√§n [priority queue](https://en.wikipedia.org/wiki/Priority_queue) tietomallin. Se on huomattavasti selke√§mpi ja helppok√§ytt√∂isempi kuin se, jonka v√§kersin itse aikaisempaan teht√§v√§√§n.

Ajattelin my√∂s yksinkertaistaa toteutusta sill√§, ett√§ toteuttaisin A*-algoritmin sijaan [Dijkstran algoritmin](https://fi.wikipedia.org/wiki/Dijkstran_algoritmi), joka on aavistuksen yksinkertaisempi. Sen voi aina muuttaa A*:ksi, jos tarvitsee. En my√∂sk√§√§n tekisi optimointia, jossa etsisin labyrintist√§ k√§√§nn√∂spaikat, koska t√§ss√§ tapauksessa mik√§ tahansa kohta voi olla potentiaalinen paikka sujahtaa sein√§n l√§pi.

Teht√§v√§ vaatii luonnollisesti sen, ett√§ labyrintti on pystytt√§v√§ ratkaisemaan ja minun on l√∂ydett√§v√§ tie maaliin ilman huijauksia. T√§m√§ toimii vertailuarvona, kun aletaan k√§ytt√§√§ huijauksia. Aloitin siis siit√§, ett√§ ratkaisisin labyrintin normaalisti. T√§m√§ on kuitenkin koodilla helppo teht√§v√§, koska kuten alussa mainitsin, reittej√§ on vain yksi. Ei siis tarvitse etsi√§ eri vaihtoehtoja. Riitt√§√§, kulkee k√§yt√§v√§√§ pitkin alusta loppuun.

Sain kirjoitettua koodin varsin nopeasti ja se tuntui nyt paljon siistimm√§lt√§ kuin aikaisemmin. Testasin sen ensin testisy√∂tteell√§ ja sain oikean lukeman askelten m√§√§r√§st√§. Sitten oma sy√∂te sis√§√§n ja tulokseksi napsahti `9316`. Seuraavaksi pit√§isi l√∂yt√§√§ kaikki oikoreitit, jotka pudottaisivat tuon askelm√§√§r√§n 9216:een tai sen alle.

Kun ratkaisin labyrintin normaalisti, j√§tin tutkimatta kaikki sellaiset naapurit, jossa oli sein√§. Nyt niit√§ ei voi j√§tt√§√§ huomioimatta, koska jokainen sein√§ on potentiaalinen oikoreitti.

Ajattelin l√§hte√§ ratkaisemaan ongelmaa siten, ett√§ ker√§isin l√∂yt√§m√§st√§ni reitist√§ jokaisen pisteen talteen. Sen j√§lkeen tutkisin, onko vieress√§ olevien seinien takana tyhj√§√§ tilaa. Jos ei ole, sen sein√§n voi ohittaa. Mutta jos siell√§ on tyhj√§√§ tilaa, sen on pakko tarkoittaa sit√§, ett√§ oikaisemme reitill√§ johonkin toiseen kohtaan. Koska minulla on reitin jokaisesta pisteess√§ tiedossa, ett√§ kuinka kaukana se on aloituspisteest√§, n√§en suoraan, paljonko reitti oikaisisi. Otetaan yksinkertainen esimerkki:

{{< highlight text >}}
#####
#...#
#.#.#
#.#.#
#S#E#
#####
{{< /highlight >}}

Yll√§ olevassa reitiss√§ aloituksesta lopetukseen on 8 askelta. Jos jokaisen ruudun et√§isyyden merkkaa kuvioon, se n√§ytt√§√§ t√§lt√§:

{{< highlight text >}}
#####
#345#
#2#6#
#1#7#
#S#8#
#####
{{< /highlight >}}

Kuvitellaan, ett√§ oikaisisin numerosta `2` oikealle. P√§√§tyisin suoraan numeroon `6`. Reitist√§ j√§isi pois askeleet `3-5` eli `3` askelta. T√§h√§n tulokseen p√§√§sisi kaavalla `6 - 2 - 1 = 3`.
Ent√§p√§ jos oikaisisin suoraan numerosta `1` oikealle? P√§√§tyisin suoraan numeroon `7`. Reitist√§ j√§isi pois askeleet `2-6` eli `5` askelta. Sama kaava: `7 - 1 - 1 = 5`.

Oikoreitti on tietenkin mahdollista tehd√§ my√∂s toiseen suuntaan, eli hyp√§t√§ numerosta `7` suoraan numeroon `1`. T√§ss√§ ei tietenk√§√§n ole mit√§√§n j√§rke√§, koska p√§√§dymme vain samalla reitill√§ aikaisempaan kohtaan. Seinien takana olevaa tyhj√§√§ tilaa tarkastaessa on siis syyt√§ tarkastaa, ett√§ menemme reitill√§ eteenp√§in, eik√§ taaksep√§in.

N√§iden lis√§ksi on huomioitava se, ett√§ oikoreitti vaatii kaksi askelta. Se on lis√§tt√§v√§ tulokseen. Ensimm√§isess√§ esimerkiss√§ p√§√§sisin maaliin 6 askeleella, eli s√§√§st√§isin vain kaksi askelta. Toisessa esimerkiss√§ nelj√§ll√§, eli s√§√§st√§isin 4 askelta.

T√§ss√§ viel√§ hieman monimutkaisempi esimerkki, jossa l√§hd√∂st√§ maaliin on `16` askelta.:

{{< highlight text >}}
#######
#E....#
#####.#
#...#.#
#.#.#.#
#S#...#
#######
{{< /highlight >}}

Kuvitellaan, ett√§ oikaisen A:sta B:een.

{{< highlight text >}}
#######
#E.B..#
###|#.#
#..A#.#
#.#.#.#
#S#...#
#######
{{< /highlight >}}

A on t√§ss√§ tapauksessa `4` askeleen p√§√§ss√§ ja B `14` askeleen p√§√§ss√§. Tuttu kaava `14 - 4 - 1 = 9`. Ohittaisimme siis `9` ruutua ja t√§m√§ pit√§√§ paikkaansa. T√§ss√§ pit√§√§ kuitenkin huomioida ne kaksi askelta. Oikoreitin kautta p√§√§sisimme maaliin `8` askeleella eli s√§√§st√§isimme `8` askelta. Kaikkien n√§iden esimerkkien avulla voi p√§√§tell√§, ett√§ s√§√§stettyjen askelten m√§√§r√§ on `ohitettujen ruutujen m√§√§r√§ - 1`.

T√§ll√§ ajatuksella l√§hdin muuttamaan koodia. Koodi kulkee jokaisen ruudun l√§pi, tarkastaa kaikki sein√§t joiden takana hyp√§t√§√§n reitiss√§ eteenp√§in, laskee niiden s√§√§st√§m√§t askeleet ja lis√§√§ laskuria aina, kun oikaisu s√§√§st√§√§ 100+ askelta.

Ei se lopulta ollut erityisen vaikeaa ja sain oikean lopputuloksen.

### Toinen osa

Toisessa osassa kysymys on ihan sama, mutta nyt huijausaskelien m√§√§r√§ voi olla maksimissaan 20.

Ik√§v√§ kyll√§ jouduin luovuttamaan t√§m√§n osalta, sill√§ [kummikoirat]({{< ref "/blogi/2024/2024-05-09-koirakummin-koiraviikko" >}}) tulivat kyl√§√§n ü•∞ Valitsin viett√§√§ aikaani niiden kanssa sen sijaan, ett√§ tuijottaisin koodia, jota olen saanut tehd√§ jo koko p√§iv√§n.

Yksi t√§hti t√§lle p√§iv√§lle riitt√§√§ ja toisen osan voi ratkaista joskus my√∂hemmin, jos haluaa.

{{< highlight shell >}}
$ go run . -d 20 -s 1
Day 20 / Step 1 result: 1293
Execution time 2.771607291s
{{< /highlight >}}

- [Haastesivu](https://adventofcode.com/2024/day/20)
- [Ratkaisun koodi](https://github.com/saaste/advent-of-code-2024/blob/main/pkg/puzzle/20.go)